# Code Explanation

## 2026-02-16 — Prevent Self-Booking (MVP 1)

### Overview

This change adds a single guard in `POST /api/bookings` to prevent riders from booking rides they own (self-booking).
Scope is intentionally minimal:

- no schema changes
- no migration changes
- no new endpoints
- no changes to booking create/cancel contracts beyond this guard

### Files Changed

#### `src/app/api/bookings/route.ts`

- Added two constants near the top of the file:
  - `SELF_BOOKING_ERROR_CODE = "SELF_BOOKING_NOT_ALLOWED"`
  - `SELF_BOOKING_ERROR_MESSAGE = "You can’t book your own ride."`
  - Responsibility: keep the self-booking conflict response stable and reusable.

- Added an early self-booking check after idempotency replay and before any write:
  - `const rideForSelfBookingCheck = await prisma.ride.findUnique({ ... select: { driverUserId: true } })`
  - `if (rideForSelfBookingCheck?.driverUserId === riderUserId) return 409 ...`
  - Responsibility by line/block:
    - fetches only `driverUserId` for the target ride (minimal data needed)
    - compares authenticated rider ID to ride owner ID
    - immediately returns `409 Conflict` with:
      - `code: SELF_BOOKING_NOT_ALLOWED`
      - `message: "You can’t book your own ride."`
    - guarantees no booking row, no seat decrement, and no idempotency mapping write on blocked self-book attempts

- Hardened transactional seat decrement predicate:
  - Added `driverUserId: { not: riderUserId }` to `tx.ride.updateMany({ where: ... })`
  - Responsibility: enforce non-self condition inside the same atomic seat-decrement query path to avoid edge-case race gaps.

- Added self-booking branch in transaction failure diagnosis:
  - inside `if (updateResult.count === 0)`, after fetching `ride`:
    - `if (ride.driverUserId === riderUserId) throw new Error(SELF_BOOKING_ERROR_CODE);`
  - Responsibility: preserve deterministic self-book conflict behavior if transaction path fails due owner/rider match.

- Added error mapping for self-booking code in catch block:
  - if `err.message === SELF_BOOKING_ERROR_CODE`, return `409` with stable `code` + `message`.
  - Responsibility: unify response shape regardless of whether self-booking was blocked at the early guard or transaction diagnosis path.

- Existing auth guard remains unchanged and exact:
  - `const auth = await requireStetsonAuth();`
  - `if (auth.error) return auth.error;`

- Existing idempotency replay remains unchanged:
  - if idempotency mapping already exists for this key, endpoint still returns existing booking `200` before self-book checks.
  - Responsibility: keep replay semantics intact for prior successful non-self bookings.

#### `src/__tests__/booking-create.test.ts`

- Updated `beforeEach` default ride mock:
  - `mockPrisma.ride.findUnique.mockResolvedValue({ id: "ride-1", driverUserId: "driver_other_user" })`
  - Responsibility: provide a stable non-self default for tests that now pass through the new guard.

- Updated idempotency replay test:
  - added assertion `expect(mockPrisma.ride.findUnique).not.toHaveBeenCalled();`
  - Responsibility: confirm replay path still short-circuits before ride lookup and seat mutation.

- Added new test: `"returns 409 and blocks self-booking without mutating seats or booking rows"`
  - sets `ride.findUnique` to same rider as driver
  - expects `409`, `code: SELF_BOOKING_NOT_ALLOWED`, and exact message
  - asserts all mutation calls are not invoked:
    - `ride.updateMany` (no seat decrement)
    - `booking.create` (no booking row)
    - `idempotencyKey.create` (no idempotency write)
    - `user.upsert` (no local user write in blocked path)
  - Responsibility: enforce and lock the self-booking invariant with explicit non-mutation guarantees.

---

## PR: GET /api/bookings/mine (design/booking-flow-endpoint)

### Overview

This PR adds one backend endpoint:

- `GET /api/bookings/mine`

It returns the authenticated rider's bookings with:

- default `CONFIRMED` filtering
- optional `status` filter (`CONFIRMED` or `CANCELLED`)
- cursor pagination (base64 JSON cursor)
- deterministic ordering (`createdAt DESC`, `id DESC`)
- strict `400` validation for invalid `cursor`, `limit`, or `status`

No booking create/cancel behavior was changed.

---

### Files Changed

#### `src/lib/booking-query.ts`

- New booking-specific query parsing helpers.
- **`BookingQueryValidationError`**
  - Error type used to return structured `400` responses (`field` + message).
- **`parseBookingLimit(value)`**
  - Applies default `20`.
  - Validates integer range `1..50`.
- **`parseBookingStatus(value)`**
  - Defaults to `CONFIRMED`.
  - Accepts only `CONFIRMED` or `CANCELLED`.
- **`decodeBookingCursor(value)`**
  - Decodes base64 JSON cursor in required shape:
    - `{ createdAt: ISO, id: bookingId }`
  - Validates UUID `id` and ISO `createdAt`.
- **`encodeBookingCursor(id, createdAt)`**
  - Encodes response `nextCursor` in the same required base64 JSON shape.

#### `src/app/api/bookings/mine/route.ts`

- New endpoint implementation for `GET /api/bookings/mine`.
- **Auth guard block**
  - Uses required guard exactly:
    - `const auth = await requireStetsonAuth();`
    - `if (auth.error) return auth.error;`
- **Query parse block**
  - Parses `limit`, `status`, and `cursor` with strict validation.
- **Filter block**
  - Always filters by `riderUserId = auth.user.clerkUserId`.
  - Applies status default of `CONFIRMED` unless `status` query is supplied.
- **Cursor semantics block**
  - Applies strict “after cursor” logic for DESC ordering:
    - `(createdAt < cursor.createdAt) OR (createdAt = cursor.createdAt AND id < cursor.id)`
- **Query block**
  - Uses `take: limit + 1` for next-page detection.
  - Uses deterministic sort:
    - `createdAt DESC`
    - `id DESC`
  - Selects response fields exactly, including nested minimal `ride` summary.
- **Response block**
  - Returns:
    - `{ items, nextCursor }`
  - `nextCursor` is generated from last returned item when extra sentinel row exists.
- **Error block**
  - Returns `400` for parsing/validation errors.
  - Returns `500` for unexpected runtime failures.

#### `src/__tests__/bookings-mine.test.ts`

- New tests for `GET /api/bookings/mine`.
- Coverage includes:
  - default `CONFIRMED` filter
  - `status=CANCELLED` behavior
  - invalid cursor returns `400`
  - invalid limit/status returns `400`
  - deterministic cursor pagination without duplicates
  - nested minimal ride summary fields included in response

---

## PR: Browsing Endpoints (design/browsing-api-endpoint)

### Overview

This PR implements backend-only browsing endpoints for MVP 1:

- `GET /api/rides`
- `GET /api/trip-requests`

Both endpoints:

- enforce `requireStetsonAuth()` exactly
- return only `ACTIVE` and not-stale records
- use strict query validation with `400` on invalid parameters
- use deterministic keyset (cursor) pagination
- return `{ items, nextCursor }`

---

### Files Changed

#### `src/lib/browse-query.ts`

- Centralized parsing and cursor utilities shared by both GET endpoints.
- **`QueryValidationError` class**
  - Carries both `field` and human-readable message so handlers can return consistent `400` payloads.
- **`parseLimit()`**
  - Enforces integer limits in range `1..50`, defaults to `20`.
- **`parseDistanceCategory()`**
  - Validates enum strictly against `SHORT | MEDIUM | LONG`.
- **`parseISODateParam()`**
  - Validates ISO-like datetime parseability for `earliestAfter` / `latestBefore`.
- **`parseBooleanParam()`**
  - Strictly accepts only `"true"` or `"false"` for `includeFull`.
- **`parseSeatsParam()`**
  - Validates positive integers for `seatsMin` / `seatsMax`.
- **`decodeCursor()`**
  - Decodes Base64 JSON and validates `{ id, timestamp }`.
  - Enforces valid UUID id and valid timestamp.
  - Throws `QueryValidationError` for malformed cursor input.
- **`encodeCursor()`**
  - Generates Base64 JSON cursor from `{ id, timestamp: ISO }` for response `nextCursor`.

#### `src/app/api/rides/route.ts`

- Added `GET /api/rides` without changing existing `POST`.
- **Auth block**
  - Executes:
    - `const auth = await requireStetsonAuth();`
    - `if (auth.error) return auth.error;`
- **Query parsing block**
  - Parses and validates: `limit`, `cursor`, `distanceCategory`, `includeFull`, `earliestAfter`, `latestBefore`, `seatsMin`.
  - Uses shared helpers from `src/lib/browse-query.ts`.
- **Base filters block**
  - Always applies:
    - `status = ACTIVE`
    - `latestDepartAt > now` (not stale)
    - `earliestDepartAt >= earliestAfter` (defaults to `now` when missing)
- **Capacity block**
  - Default (`includeFull=false`) enforces `seatsAvailable >= 1`.
  - `includeFull=true` removes default full-ride exclusion.
  - `seatsMin` overrides threshold when provided.
- **Cursor predicate block**
  - Applies strict “after cursor” logic for deterministic order:
    - `(earliestDepartAt > cursor.timestamp) OR (earliestDepartAt = cursor.timestamp AND id > cursor.id)`
- **Fetch block**
  - Uses `take: limit + 1`, `orderBy earliestDepartAt ASC, id ASC`, and stable select shape (`RideSummary`).
- **Response block**
  - Returns `{ items, nextCursor }`.
  - `nextCursor` is generated from the last returned item when an extra sentinel row exists.
- **Error handling block**
  - Returns `400` for validation errors.
  - Returns `500` for unexpected errors.

#### `src/app/api/trip-requests/route.ts`

- Added `GET /api/trip-requests` without changing existing `POST`.
- **Auth block**
  - Same required `requireStetsonAuth()` guard pattern.
- **Query parsing block**
  - Parses and validates: `limit`, `cursor`, `distanceCategory`, `earliestAfter`, `latestBefore`, `seatsMax`.
- **Base filters block**
  - Always applies:
    - `status = ACTIVE`
    - `latestDesiredAt > now` (not stale)
- **Optional filter block**
  - Applies `earliestDesiredAt >= earliestAfter`, `latestDesiredAt <= latestBefore`, distance category filter, and `seatsNeeded <= seatsMax`.
- **Cursor predicate block**
  - Applies strict keyset predicate:
    - `(earliestDesiredAt > cursor.timestamp) OR (earliestDesiredAt = cursor.timestamp AND id > cursor.id)`
- **Fetch block**
  - Uses `take: limit + 1`, `orderBy earliestDesiredAt ASC, id ASC`, stable select shape (`TripRequestSummary`).
- **Response block**
  - Returns `{ items, nextCursor }` with Base64 cursor generation from the last returned row.
- **Error handling block**
  - Returns `400` for invalid params/cursor and `500` for unexpected issues.

#### `src/__tests__/rides-browse.test.ts`

- Added GET browse tests for rides.
- Significant coverage:
  - ACTIVE + not-stale baseline filtering.
  - Default full-ride exclusion and `includeFull=true` override.
  - `distanceCategory` + `seatsMin` filter application.
  - `400` on invalid cursor.
  - `400` on invalid enum/date/limit values.
  - Deterministic pagination across pages with no duplicate IDs.

#### `src/__tests__/trip-requests-browse.test.ts`

- Added GET browse tests for trip requests.
- Significant coverage:
  - ACTIVE + not-stale baseline filtering.
  - `distanceCategory`, `seatsMax`, `earliestAfter`, `latestBefore` filters.
  - `400` on invalid cursor.
  - `400` on invalid enum/date/limit values.
  - Deterministic cursor pagination with no duplicate IDs.

#### `prisma/schema.prisma`

- Added minimal cursor-order indexes (blueprint-aligned):
  - `Ride`: `@@index([earliestDepartAt, id])`
  - `TripRequest`: `@@index([earliestDesiredAt, id])`
- Purpose: support deterministic keyset pagination ordering efficiently.

#### `prisma/migrations/20260214221500_add_browse_cursor_indexes/migration.sql`

- Adds DB indexes matching schema updates:
  - `rides(earliest_depart_at, id)`
  - `trip_requests(earliest_desired_at, id)`
- Keeps migration scope minimal and specific to browse endpoint pagination performance.

---

## Patch: Next.js Proxy-Only Middleware Fix (codex/frontend-auth-gating-mvp1)

### Overview

This patch resolves a Next.js build failure caused by having both `src/proxy.ts` and `src/middleware.ts`.
In Next.js 16, this project must use `src/proxy.ts` only for middleware/proxy behavior.

### Files Changed

#### `src/middleware.ts` (removed)

- Deleted the shim file to avoid dual-detection conflict:
  - `Both middleware file ... and proxy file ... are detected. Please use ... proxy.ts only.`
- `src/proxy.ts` remains the single source for Clerk middleware handler and matcher config.

---

## Patch: Clerk Middleware Coverage Fix (codex/frontend-auth-gating-mvp1)

### Overview

This patch fixes a production server error by ensuring Clerk middleware runs on frontend page requests (not only API routes).
Without this, server-side calls like `auth()` and `currentUser()` on pages can fail at runtime in Vercel.

### Files Changed

#### `src/proxy.ts`

- Updated `config.matcher` from API-only to page+API coverage.
- New matcher behavior:
  - Includes app/page routes.
  - Includes `/api` and `/trpc` routes.
  - Excludes `_next` internals and static assets.
- This keeps Clerk session context available for frontend route gating and restricted-access pages.

---

## PR: Frontend Auth Flow & Route Protection (codex/frontend-auth-gating-mvp1)

### Overview

This PR adds frontend-only protection for app pages using Clerk in the Next.js App Router.
It enforces that protected pages are accessible only to users who are:

- signed in
- using a verified email
- using a verified `@stetson.edu` email

If a signed-in user is blocked (unverified or non-stetson), they are redirected to a dedicated `Access Restricted` UX page with clear next actions.

---

### Files Changed

#### `src/app/page.tsx` -> moved to `src/app/(protected)/page.tsx`

- The root homepage is now placed inside a protected route group.
- This preserves route URL (`/`) while making it subject to the protected layout guard.
- The page content itself was not functionally changed; only route organization changed for gating.

#### `src/app/(protected)/layout.tsx`

- Adds centralized frontend route protection for everything in the `(protected)` group.
- **`const user = await currentUser();`**
  - Reads Clerk session on the server for the current request.
- **`if (!user) redirect("/sign-in");`**
  - Ensures signed-out users are redirected to Clerk sign-in before protected content renders.
- **`const access = evaluateFrontendAccess(user);`**
  - Runs frontend authorization logic (verified + stetson email check).
- **`if (!access.allowed) redirect("/access-restricted?...")`**
  - Redirects unauthorized signed-in users to the blocked-user UX with a reason code in query params.
- **`return <>{children}</>;`**
  - Renders protected content only when both auth and authorization pass.

#### `src/lib/frontend-auth.ts`

- New frontend authorization utility used by protected layouts/pages.
- **`RestrictionReason`**
  - Enumerates explicit blocked states: missing email, unverified email, non-stetson domain.
- **`evaluateFrontendAccess(user)`**
  - Core decision function:
    1. Rejects missing user/email list.
    2. Requires at least one verified email.
    3. Requires at least one verified email ending with `@stetson.edu`.
    4. Returns success with normalized verified stetson email.
- **`getRestrictionCopy(reason)`**
  - Maps block reasons to user-facing text for the restricted page.

#### `src/app/access-restricted/page.tsx`

- Implements the blocked-user UX page required for frontend authorization failures.
- **Server `searchParams` parsing + reason validation**
  - Reads reason code passed by protected layout via page `searchParams` and validates it to known values.
- **Requirement message block**
  - Explains that a verified `@stetson.edu` email is required.
- **Action buttons**
  - `Sign out` (Clerk `SignOutButton` with redirect to `/sign-in`)
  - `Switch account` is conditional:
    - Signed in: Clerk `UserButton` for account/session switching
    - Signed out: link to `/sign-in`
  - `Verify email` (link to `/user-profile`)
- This page is intentionally minimal and consistent with existing app styling.

#### `src/app/user-profile/[[...user-profile]]/page.tsx`

- Adds a Clerk-hosted profile route so blocked users have a direct place to manage/verify email.
- **`<SignedIn><UserProfile ... /></SignedIn>`**
  - Shows profile only for authenticated users.
- **`<SignedOut><RedirectToSignIn /></SignedOut>`**
  - Prevents anonymous access and sends signed-out users to sign-in.

---

### Scope Confirmation

- Implemented: frontend auth flow and route protection.
- Implemented: Clerk-based gating for protected pages.
- Implemented: blocked-user access UX with required actions.
- Not implemented: backend guard changes, `/api/*` behavior changes, business logic/model changes.

---

## PR: Backend Authentication & Authorization (feat/backend-auth)

### Overview

This PR implements backend authentication and authorization enforcement for MVP 1.
All protected API routes require a valid Clerk session AND a verified @stetson.edu email.

---

### Files Changed

#### `.env.local` / `.env.example`

- **`.env.local`**: Contains the actual environment variable values (gitignored).
- **`.env.example`**: Committed reference showing all required environment variables.
- Variables:
  - `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY` — Clerk publishable key (used client-side)
  - `CLERK_SECRET_KEY` — Clerk secret key (used server-side)
  - `NEXT_PUBLIC_CLERK_SIGN_IN_URL` / `NEXT_PUBLIC_CLERK_SIGN_UP_URL` — Clerk redirect URLs
  - `DATABASE_URL` — PostgreSQL connection string for Prisma

#### `prisma/schema.prisma`

- Defines the PostgreSQL datasource and Prisma client generator.
- **`User` model**: Local user record linked to Clerk.
  - `id` — UUID primary key (auto-generated).
  - `clerkUserId` — Unique string mapped from Clerk's user ID (`clerk_user_id` column). Ensures one local record per Clerk user.
  - `email` — The user's verified @stetson.edu email address.
  - `createdAt` / `updatedAt` — Timestamps for record creation and last update.
  - `@@map("users")` — Maps the model to a `users` table in PostgreSQL.

#### `prisma.config.ts`

- Auto-generated Prisma config. Loads `DATABASE_URL` from environment via `dotenv/config`.
- Points to `prisma/schema.prisma` and `prisma/migrations` directory.

#### `src/lib/prisma.ts`

- **Singleton Prisma client**.
- Uses `globalThis` caching to prevent multiple PrismaClient instances during Next.js dev hot-reloads.
- `globalForPrisma.prisma` stores the client globally; in production, a fresh instance is created per cold start.

#### `src/lib/auth.ts`

- **`requireStetsonAuth()`** — The core auth guard function.
- **Step 1**: Calls `currentUser()` from `@clerk/nextjs/server` to get the Clerk session user.
  - If `null` → returns `NextResponse` with **401** and `"Authentication required."` message.
- **Step 2**: Iterates `user.emailAddresses` looking for an email where:
  - `verification.status === "verified"` — Email must be verified through Clerk.
  - `emailAddress.toLowerCase().endsWith("@stetson.edu")` — Must be a Stetson University email (case-insensitive).
  - If no matching email → returns `NextResponse` with **403** and `"Access restricted to verified @stetson.edu email addresses."` message.
- **Step 3**: Returns `AuthedUser` object with `clerkUserId` and `primaryStetsonEmail`.
- **Type `AuthResult`**: Discriminated union — either `{ user: AuthedUser }` or `{ error: NextResponse }`. Enables clean pattern matching in route handlers.

#### `src/middleware.ts`

- Exports `clerkMiddleware()` from `@clerk/nextjs/server`.
- **Purpose**: Makes Clerk auth state (session, user) available to all matched routes. Without this, `currentUser()` would return `null` for every request.
- **`config.matcher`**: Applies to all `/api/(.*)` routes and non-static pages. Skips Next.js internals (`_next`) and static assets (images, fonts, etc.).
- **Note**: This middleware does NOT enforce authorization — it only provides session data. Authorization is enforced per-route by `requireStetsonAuth()`.

#### `src/app/layout.tsx`

- Wraps the entire app with `<ClerkProvider>` — required for Clerk to manage sessions.
- Updates metadata title/description to "Desti".
- **Note**: This is the only frontend file touched, and it's the minimal change needed for Clerk to function. No frontend route protection or UI logic is added.

#### `src/app/api/me/route.ts`

- **`GET /api/me`** — Returns the current user's profile.
- **Line-by-line**:
  1. Calls `requireStetsonAuth()` — if it returns an error, that error response is returned immediately (401 or 403).
  2. Calls `prisma.user.findUnique({ where: { clerkUserId } })` to check if a local user already exists.
  3. Calls `prisma.user.upsert()` with:
     - `where: { clerkUserId }` — Matches on the unique Clerk ID.
     - `create: { clerkUserId, email }` — Creates the user if missing.
     - `update: { email }` — Keeps the email in sync if user already exists.
  4. Sets `created = !existingUser` — `true` if this was the first call for this user.
  5. Returns JSON with `clerkUserId`, `primaryVerifiedEmail`, `created`, and `localUser` (safe fields only: id, clerkUserId, email, createdAt, updatedAt).
- **Idempotency**: `upsert` ensures no duplicate users are created even under concurrent requests.

#### `src/app/api/health/route.ts`

- **`GET /api/health`** — Public health-check endpoint. No authentication required.
- Returns `{ status: "ok", timestamp: "..." }`.
- Useful for uptime monitoring, load balancer health checks, and deployment verification.

#### `.gitignore`

- Updated to allow `.env.example` to be committed while still excluding `.env`, `.env.local`, and `*.local` env files.

---

### API Responses Summary

| Endpoint | Auth Required | 401 When | 403 When | 200 Response |
|-----------|--------------|----------|----------|-------------|
| `GET /api/health` | No | — | — | `{ status, timestamp }` |
| `GET /api/me` | Yes | No Clerk session | No verified @stetson.edu email | `{ clerkUserId, primaryVerifiedEmail, created, localUser }` |

---

## 2026-02-12 — Ride Creation (POST /api/rides)

### Overview

This PR implements the ride creation endpoint for MVP 1. Drivers with verified @stetson.edu emails can create rides. The endpoint enforces comprehensive validation, uses idempotency keys to prevent duplicate rides under retries/concurrency, and derives server-side fields (driverUserId, seatsAvailable, status) from auth context and business rules.

---

### Files Changed

#### `prisma/schema.prisma`

- **`DistanceCategory` enum** — Defines `SHORT`, `MEDIUM`, `LONG` values. Used by the `Ride` model to categorize trip distance.
- **`RideStatus` enum** — Defines `ACTIVE` for MVP 1. Room to add `CANCELLED`, `COMPLETED` later.
- **`Ride` model** — Mapped to `rides` table. Contains:
  - `id` — UUID primary key (auto-generated).
  - `driverUserId` — Clerk user ID of the driver. FK to `User.clerkUserId`.
  - `originText` / `destinationText` — Trimmed text strings for origin and destination (3–200 chars).
  - `earliestDepartAt` / `latestDepartAt` — Departure time window (validated: latest > earliest, window ≤ 48h, earliest ≥ now − 10min).
  - `distanceCategory` — Enum value (`SHORT` | `MEDIUM` | `LONG`).
  - `priceCents` — Integer price in cents (≥ 0).
  - `seatsTotal` / `seatsAvailable` — Integer seats (1–8). `seatsAvailable` initialized to `seatsTotal` on create.
  - `status` — Defaults to `ACTIVE`.
  - `createdAt` / `updatedAt` — Auto-managed timestamps.
  - `driver` relation — Links to User via `driverUserId` → `User.clerkUserId`.
  - `idempotencyKeys` relation — Back-relation to `IdempotencyKey`.
- **`IdempotencyKey` model** — Mapped to `idempotency_keys` table. Contains:
  - `id` — UUID primary key.
  - `driverUserId` — Clerk user ID.
  - `idempotencyKey` — Client-provided idempotency key string.
  - `rideId` — FK to the `Ride` created with this key.
  - `createdAt` — Timestamp.
  - `@@unique([driverUserId, idempotencyKey])` — Composite unique constraint. **This is the concurrency safety mechanism** — prevents two rides from being created for the same driver + key, even under concurrent requests.
- **`User` model** — Added `rides Ride[] @relation("DriverRides")` back-relation.

#### `prisma/migrations/20260212190911_add_ride_and_idempotency_models/migration.sql`

- Auto-generated Prisma migration that:
  - Creates `DistanceCategory` and `RideStatus` enums in PostgreSQL.
  - Creates the `rides` table with all columns and FK to `users.clerk_user_id`.
  - Creates the `idempotency_keys` table with FK to `rides.id`.
  - Adds unique index on `(driver_user_id, idempotency_key)`.

#### `src/app/api/rides/route.ts`

- **`POST` handler** — The main endpoint implementation. Flow:
  1. **Auth guard** (`requireStetsonAuth()`) — Rejects unauthenticated (401) or non-stetson (403) users. Derives `driverUserId` from `auth.user.clerkUserId`. Client-supplied `driverUserId` is explicitly deleted from the body.
  2. **Idempotency-Key header** — Read from `request.headers.get("Idempotency-Key")`. If missing or empty after trim → 400.
  3. **Body parsing** — `request.json()` wrapped in try/catch for invalid JSON → 400.
  4. **`validateRideBody(body)`** — Returns `{ errors, parsed }`. If errors exist → 400 with `{ error, message, details }` where `details` is an array of `{ field, message }` objects.
  5. **Idempotency check** — `prisma.idempotencyKey.findUnique()` with composite key `(driverUserId, idempotencyKey)`. If found → return the associated ride with **200** (replay).
  6. **User upsert** — `prisma.user.upsert()` ensures a local User record exists before creating the ride. Required because `rides.driver_user_id` has a FK to `users.clerk_user_id`. Idempotent — creates on first call, syncs email on subsequent calls.
  7. **Ride creation** — `prisma.ride.create()` with derived fields: `seatsAvailable = seatsTotal`, `status = "ACTIVE"`.
  8. **Idempotency mapping creation** — `prisma.idempotencyKey.create()` inside try/catch. If P2002 unique constraint violation (race condition) → fetch existing mapping and return ride with **200**.
  9. **201 response** — Return created ride JSON.
  10. **500 catch-all** — Logs unexpected errors, returns generic error response.
- **`validateRideBody(body)`** — Validation function. Returns field-level error array:
  - `originText` / `destinationText` — Must be strings, trimmed, 3–200 chars.
  - `earliestDepartAt` / `latestDepartAt` — Must parse as valid Date objects.
  - Cross-field: `latestDepartAt > earliestDepartAt`, window ≤ 48h.
  - `earliestDepartAt ≥ now − 10 minutes` (clock skew grace).
  - `distanceCategory` — Must be in `DistanceCategory` enum set.
  - `priceCents` — Integer ≥ 0.
  - `seatsTotal` — Integer 1–8.
- **`isPrismaUniqueConstraintError(err)`** — Type guard checking for Prisma error code `P2002`. Used in the idempotency conflict handler.

#### `src/__tests__/ride-create.test.ts`

- **Test file** — 7 unit tests using Vitest with mocked auth and Prisma:
  1. `returns 201 with created ride on successful create` — Verifies status, ride ID, driverUserId, seatsAvailable, and status in response.
  2. `returns 400 when Idempotency-Key header is missing` — Request has no Idempotency-Key header.
  3. `returns 400 when earliestDepartAt is after latestDepartAt` — earliest 5h from now, latest 1h from now.
  4. `returns 400 when departure window exceeds 48 hours` — 49h gap between earliest and latest.
  5. `returns 400 when seatsTotal is outside 1-8 range` — seatsTotal = 10.
  6. `returns 400 when priceCents is negative` — priceCents = -100.
  7. `returns 200 with existing ride on idempotency replay` — Mock returns existing mapping, verifies same ride ID returned and no new ride created.
- **Mock setup** — Uses `vi.hoisted()` to declare mock objects before `vi.mock()` factory functions (which are hoisted). Mocks: `requireStetsonAuth`, `prisma`, and `DistanceCategory` enum.
- **Helpers** — `validBody()` builds a valid request body, `makeRequest()` builds a Request object, `successAuth()` returns mock auth, `fakeRide()` returns a mock Ride object.

#### `vitest.config.ts`

- Vitest configuration file. Sets test environment to `node` and configures `@/` path alias to resolve to `./src/` (matches `tsconfig.json` paths).

#### `package.json`

- Added `"test": "vitest run"` script.
- Added `vitest` as a devDependency.

## Patch: Trip Request Creation Endpoint (feature/trip-request-create-idempotency)

### Overview

Adds POST /api/trip-requests — a rider-authored trip request endpoint for MVP 1.
Also generalizes the idempotency_keys table to support both rides and trip requests,
avoiding a redundant parallel idempotency system.

### Files Changed

#### `prisma/schema.prisma`

- **TripRequestStatus enum**: ACTIVE, CANCELLED (CANCELLED in schema only; no cancellation endpoint).
- **IdempotencyEntityType enum**: RIDE, TRIP_REQUEST — discriminator for the shared idempotency table.
- **TripRequest model**: riderUserId (FK → users.clerk_user_id), originText, destinationText,
  earliestDesiredAt, latestDesiredAt, distanceCategory, seatsNeeded, status, timestamps.
  Mapped to `trip_requests` table.
- **IdempotencyKey model changes**:
  - `driverUserId` → `userId` (column `user_id`) — now generic for any user.
  - Added `entityType` — discriminates between RIDE and TRIP_REQUEST entries.
  - `rideId` → optional (nullable) for trip request entries.
  - Added optional `tripRequestId` (FK → trip_requests.id).
  - Unique constraint changed from `(driverUserId, idempotencyKey)` to `(userId, idempotencyKey, entityType)`.
- **User model**: Added `tripRequests` back-relation.

#### `prisma/migrations/.../migration.sql`

- Custom migration with data-migration steps:
  1. Creates enums + trip_requests table.
  2. Adds `user_id` and `entity_type` as nullable columns.
  3. Migrates existing rows: copies `driver_user_id` → `user_id`, sets `entity_type` = 'RIDE'.
  4. Sets new columns to NOT NULL.
  5. Drops old `driver_user_id` column, makes `ride_id` nullable.
  6. Creates new unique index and foreign keys.

#### `src/app/api/rides/route.ts` (minimal required update)

- All IdempotencyKey queries updated: `driverUserId` → `userId`, added `entityType: "RIDE"`.
- Compound unique key references changed from `driverUserId_idempotencyKey` to `userId_idempotencyKey_entityType`.
- No changes to ride business logic.

#### `src/app/api/trip-requests/route.ts` (new file)

Handler follows the same architecture as rides/route.ts:

1. **Auth guard** — `requireStetsonAuth()`, derives `riderUserId = auth.user.clerkUserId`.
2. **Idempotency-Key header** — required, trimmed, 400 if missing.
3. **JSON body parsing** — type guard rejects non-object JSON (null/arrays/primitives).
4. **Client riderUserId rejected** — `delete body.riderUserId` prevents client override.
5. **Validation** — `validateTripRequestBody()`:
   - originText/destinationText: string, trimmed, 3–200 chars.
   - earliestDesiredAt/latestDesiredAt: valid ISO datetimes.
   - latestDesiredAt > earliestDesiredAt (strict).
   - Desired window ≤ 48h.
   - earliestDesiredAt ≥ now - 10min (clock skew grace).
   - distanceCategory: SHORT | MEDIUM | LONG.
   - seatsNeeded: integer 1–8.
6. **Idempotency check** — `findUnique` with `entityType: "TRIP_REQUEST"`. Returns 200 on replay.
7. **User upsert** — ensures User record exists for FK satisfaction.
8. **Atomic transaction** — `prisma.$transaction` creates TripRequest + IdempotencyKey together.
   P2002 rolls back the trip request (no orphans).
9. **P2002 catch** — fetches existing mapping, returns 200.
10. **Success** — returns 201 with created TripRequest.

#### `src/__tests__/ride-create.test.ts`

- Updated idempotency replay mock data: `driverUserId` → `userId`, added `entityType: "RIDE"`.

#### `src/__tests__/trip-request-create.test.ts` (new file)

Seven test cases:

  1. `returns 201 with created trip request on successful create` — verifies $transaction atomicity.
  2. `returns 400 when Idempotency-Key header is missing`.
  3. `returns 400 when earliestDesiredAt is after latestDesiredAt`.
  4. `returns 400 when desired window exceeds 48 hours`.
  5. `returns 400 when seatsNeeded is outside 1-8 range`.
  6. `returns 400 when distanceCategory is invalid` — tests "VERY_FAR" rejected.
  7. `returns 200 with existing trip request on idempotency replay`.
Mock setup mirrors ride tests: `vi.hoisted()` for mock objects, mocks for auth/prisma/DistanceCategory.

## Patch: Harden IdempotencyKey FK Semantics & CHECK Constraint

### Overview

Tightens the idempotency_keys table at the database level to prevent two classes of bugs:

1. **Dangling idempotency keys** — where a ride or trip request gets deleted but the idempotency
   key row survives with a NULL FK, causing subsequent replays to return `null` bodies as 200 OK.
2. **Mismatched entity types** — where a row could theoretically have `entity_type = 'RIDE'` but
   point at a `trip_request_id`, or have both FKs set/null simultaneously.

### Why ON DELETE RESTRICT instead of SET NULL

**Before (SET NULL)**:

```
idempotency_keys.ride_id  →  rides.id  ON DELETE SET NULL
```

If a ride gets deleted (now or via a future admin API), the FK becomes NULL. On the next
replay with the same Idempotency-Key, the handler calls `idempotencyKey.findUnique({ include: { ride: true } })`
and gets `{ ride: null }`. The endpoint would then return `NextResponse.json(null, { status: 200 })` —
a successful HTTP 200 with a null body. The client thinks everything is fine, but the ride is gone.

**After (RESTRICT)**:

```
idempotency_keys.ride_id  →  rides.id  ON DELETE RESTRICT
```

PostgreSQL now **blocks** any `DELETE FROM rides WHERE id = ?` if an idempotency_keys row references it.
This forces the application to explicitly clean up the idempotency mapping first before deleting the
referenced entity — making the deletion a deliberate, multi-step operation rather than a silent data loss.

The same logic applies to `trip_request_id → trip_requests.id`.

### Why the CHECK constraint

The `idempotency_keys` table is polymorphic — it stores mappings for both rides and trip requests
in the same table, distinguished by `entity_type`. Without a CHECK constraint, the DB permits
rows that violate the intended exclusivity rules:

| Scenario                              | entity_type  | ride_id | trip_request_id | Valid? |
|---------------------------------------|-------------|---------|-----------------|--------|
| Ride mapping                          | RIDE        | ✓ set   | NULL            | ✅ Yes  |
| Trip request mapping                  | TRIP_REQUEST| NULL    | ✓ set           | ✅ Yes  |
| Both FKs set                          | RIDE        | ✓ set   | ✓ set           | ❌ No   |
| Wrong FK for type                     | RIDE        | NULL    | ✓ set           | ❌ No   |
| Neither FK set                        | RIDE        | NULL    | NULL            | ❌ No   |

The CHECK constraint enforces this at the database level:

```sql
CHECK (
    (entity_type = 'RIDE'         AND ride_id IS NOT NULL AND trip_request_id IS NULL) OR
    (entity_type = 'TRIP_REQUEST' AND trip_request_id IS NOT NULL AND ride_id IS NULL)
)
```

This is **defense in depth** — the application code already sets these correctly, but the CHECK
ensures no bug, migration, or manual SQL can create an invalid row.

### Files Changed

#### `prisma/schema.prisma`

- Added `onDelete: Restrict` to both `ride` and `tripRequest` relations on the `IdempotencyKey` model.
  Prisma's default for optional relations is `SetNull`; we now explicitly override this.

#### `prisma/migrations/.../harden_idempotency_fk_and_check/migration.sql`

1. **Drops** both existing FK constraints (which had `ON DELETE SET NULL`).
2. **Recreates** them with `ON DELETE RESTRICT ON UPDATE CASCADE`.
3. **Adds** `chk_idempotency_entity_fk` CHECK constraint enforcing the entity-type exclusivity rules.

Note: Prisma doesn't natively support CHECK constraints, so this was added as raw SQL in the
migration. Prisma will not manage or drop this constraint — it lives as a "DB-only" safeguard.

## 2026-02-13 — Store Route and Timing Data (MVP 1)

### Overview

Adds three optional fields to both `Ride` and `TripRequest` models so that creators can attach route context and a preferred timing anchor at creation time. All fields are nullable with no breaking changes.

### Fields Added

| Field | Type | Validation |
|-------|------|------------|
| `pickupInstructions` | `String?` | If provided: trimmed, non-empty, ≤ 500 chars |
| `dropoffInstructions` | `String?` | If provided: trimmed, non-empty, ≤ 500 chars |
| `preferredDepartAt` | `DateTime?` | If provided: valid ISO datetime, must fall within `[earliest, latest]` window |

### Files Changed

#### `prisma/schema.prisma`

- Added `pickupInstructions`, `dropoffInstructions`, `preferredDepartAt` to both `Ride` and `TripRequest` models.
- All columns mapped to snake_case (`pickup_instructions`, `dropoff_instructions`, `preferred_depart_at`).
- All nullable, default `NULL`.

#### `prisma/migrations/20260213190344_add_route_context_and_timing/migration.sql`

- Six `ALTER TABLE ... ADD COLUMN` statements (3 per table). No data migration needed — all nullable.

#### `src/app/api/rides/route.ts`

- Extended `validateRideBody()` with validation blocks for the 3 new optional fields.
- Instructions: if provided and not a string → error. If string but empty/whitespace after trim → error. If > 500 chars → error.
- `preferredDepartAt`: if provided, parsed as Date, checked against `[earliestDepartAt, latestDepartAt]` range.
- Extended `parsed` return type with `pickupInstructions: string | null`, `dropoffInstructions: string | null`, `preferredDepartAt: Date | null`.
- Added the 3 fields to `tx.ride.create({ data })`.

#### `src/app/api/trip-requests/route.ts`

- Same pattern as rides. `preferredDepartAt` validated against `[earliestDesiredAt, latestDesiredAt]`.

#### `src/__tests__/ride-create.test.ts`

Five new tests (#8–#12):

- 201 with all 3 new fields (verifies trimming).
- 400 for whitespace-only `pickupInstructions`.
- 400 for `dropoffInstructions` > 500 chars.
- 400 for `preferredDepartAt` before `earliestDepartAt`.
- 400 for `preferredDepartAt` after `latestDepartAt`.

#### `src/__tests__/trip-request-create.test.ts`

Five new tests (#16–#20): same validation scenarios adapted for trip request field names (`earliestDesiredAt`/`latestDesiredAt`).

### Test Results

All 32 tests pass (12 ride + 20 trip-request).

## 2026-02-14 — Browsing API Design (MVP 1)

### Overview

Created the definitive design blueprint for `GET /api/rides` and `GET /api/trip-requests`. Because listing endpoints are high-traffic and complex (pagination, filtering, sorting), this PR delivers the *contract* and *contracts* only, without the implementation code.

### Files Added

#### `docs/browsing_mvp1_contract.md`

- **The Bible** for the browsing implementation.
- Specifies strict query parameter validation rules.
- Defines the **Keyset Pagination** strategy (Cursor-based) to ensure O(1) performance and prevent offset drift.
- Defines deterministic sorting: `Timestamp ASC` + `ID ASC`.
- Provides the exact Prisma `where` clause structure to handle cursor predicates safely.
- Outlines the testing matrix required for the implementation phase.

#### `src/lib/pagination.ts`

- A utility module to centralize pagination logic.
- **`encodeCursor` / `decodeCursor`**: Handles Base64 wrapping of the `{id, timestamp}` cursor object.
- **`CursorSchema`**: Zod schema to validate decoded cursors structure at runtime.
- **`parseLimit`**: Enforces the 1–50 limit constraint (default 20).
- **`PaginatedResponse<T>`**: TypeScript interface ensuring consistent API response shapes.

## 2026-02-16 — Booking Flow (MVP 1)

### Overview

Implements the core booking transaction logic. Riders can book specific rides, decrementing seat inventory atomically. Includes strict idempotency to prevent double-booking or overbooking race conditions, and cancellability that restores seat inventory.

### Files Changed

#### `prisma/schema.prisma`

- **`Booking` model**:
  - `id`, `rideId`, `riderUserId`, `seatsBooked`, `status` (CONFIRMED/CANCELLED).
  - Relations to `Ride`, `User`, and `IdempotencyKey`.
- **`BookingStatus` enum**: CONFIRMED, CANCELLED.
- **`IdempotencyKey` updates**:
  - Added `bookingId` field and relation.
  - Added `BOOKING` to `IdempotencyEntityType`.

#### `prisma/migrations/.../add_booking_model/migration.sql`

- Added `bookings` table.
- **Custom SQL**: Added partial unique index `UNIQUE(ride_id, rider_user_id) WHERE status = 'CONFIRMED'`.
  - Ensures a rider can only have *one* active booking per ride.
  - Allows re-booking if the previous one was CANCELLED.

#### `src/app/api/bookings/route.ts`

- **`POST /api/bookings`**
- **Auth**: Requires verified Stetson email.
- **Validation**: `seatsBooked` (1-8), `rideId` exists.
- **Transaction**:
  1. **Decrement Seats**: `UPDATE rides SET seats_available = seats_available - N WHERE id = ? AND seats_available >= N`.
     - Returns 0 count if race condition or capacity fails -> throws 409.
  2. **Create Booking**: Inserts booking record.
  3. **Idempotency**: Inserts key.
- **Concurrency**: Relies on atomic database constraints to prevent overbooking.

#### `src/app/api/bookings/[bookingId]/cancel/route.ts`

- **`POST .../cancel`**
- **Auth**: Only the booking owner can cancel.
- **Logic**:
  - Checks if already cancelled (idempotent 200).
  - Updates status to `CANCELLED`.
  - Atomically increments `ride.seatsAvailable` by `seatsBooked`.

#### `src/__tests__/booking-create.test.ts` & `booking-cancel.test.ts`

- **Unit Tests**:
  - Verify success flow (transaction atomicity).
  - Verify capacity constraints (mocked race conditions).
  - Verify double-booking constraints.
  - Verify authorization rules.
  - Verify idempotency replays.

## 2026-02-18 — Trip Request Offers

### Overview

This change implements the write-side of the Trip Request Offer flow. Drivers can now offer rides to specific Trip Requests, and Riders can accept those offers. The implementation includes a new database model, status management, and strict business rules (idempotency, one-active-offer limits).

### Files Changed

#### `prisma/schema.prisma`

- **`Offer` model**: Mapped to `Offer` table (keeping PascalCase for table name was a minor inconsistency, typically we use snake_case map, but functionality is unaffected).
  - `id`: UUID.
  - `tripRequestId`: FK to TripRequest.
  - `driverUserId`: FK to User (Driver).
  - `riderUserId`: FK to User (Rider).
  - `seatsOffered`: Int.
  - `priceCents`: Int.
  - `status`: Enum (`PENDING`, `ACCEPTED`, `CANCELLED`).
  - `message`: Optional string.
  - Indexes: Covered by FKs and status queries.
- **`OfferStatus` enum**: Defines the three states.
- **`IdempotencyEntityType`**: Added `OFFER`.
- **`IdempotencyKey` check constraints**: Updated raw SQL to support `OFFER` type.

#### `prisma/migrations/20260217213327_add_offer_model/migration.sql`

- Creates `Offer` table and `OfferStatus` enum.
- Adds partial unique index: `CREATE UNIQUE INDEX offer_trip_request_accepted_unique ON "Offer"("trip_request_id") WHERE status = 'ACCEPTED'`.
  - **Purpose**: Database-level guarantee that a TripRequest can have at most ONE accepted offer.

#### `prisma/migrations/20260217214323_add_idempotency_check_offer/migration.sql`

- Updates the `chk_idempotency_entity_fk` check constraint to allow `entity_type = 'OFFER'` with `offer_id` set (and others null).

#### `src/app/api/trip-requests/[tripRequestId]/offers/route.ts`

- **`POST` handler** (Create Offer):
  1. **Auth**: Drivers only (must have `@stetson.edu` email).
  2. **Validation**:
     - `seatsOffered`: 1-8.
     - `priceCents`: >= 0.
     - `message`: max 500 chars.
  3. **Guards**:
     - **Self-offer**: Driver cannot offer on their own request.
     - **One-active-offer**: Driver cannot have >1 PENDING/ACCEPTED offer for the same request.
     - **Request State**: TripRequest must be `ACTIVE`.
  4. **Idempotency**: Standard `Idempotency-Key` header support.
  5. **Transaction**: Creates `Offer` + `IdempotencyKey` atomically.

#### `src/app/api/offers/[offerId]/accept/route.ts`

- **`POST` handler** (Accept Offer):
  1. **Auth**: Only the **Rider** who owns the request can accept.
  2. **Guards**:
     - Offer must be `PENDING`.
     - TripRequest must be `ACTIVE`.
     - **Double-Accept**: Checks if another offer is already `ACCEPTED` (redundant with DB index, but provides better error message).
  3. **Update**: Sets status to `ACCEPTED`.

#### `src/app/api/offers/[offerId]/cancel/route.ts`

- **`POST` handler** (Cancel Offer):
  1. **Auth**:
     - **Driver**: Can cancel their own offer if `PENDING`.
     - **Rider**: Can cancel an offer on their request if `PENDING` or `ACCEPTED`.
  2. **Update**: Sets status to `CANCELLED`.
  3. **Idempotency**: Returns 200 if already `CANCELLED`.

#### `src/__tests__/offer-lifecycle.test.ts`

- **Integration Tests**: 10 scenarios using `vitest` and `prisma` mock/test-db.
  1. Create Success.
  2. Idempotency Replay.
  3. Self-offer blocked (409).
  4. Multiple active offers blocked (409).
  5. Accept Success.
  6. Driver acceptance blocked (403).
  7. Double-accept blocked (409).
  8. Driver cancel success.
  9. Driver cancel accepted blocked (409).
  10. Rider cancel accepted success.

## 2026-02-18 — Offer Acceptance Creates Booking

### Overview

Added the transactional logic for Rider acceptance. when a Rider accepts an offer, the system now automatically creates a Confirmed Booking, closes the Trip Request, and cancels all other pending offers for that request.

### Files Changed

#### `prisma/schema.prisma`

- **`Booking` model**:
    - Made `rideId` optional (nullable).
    - Added `tripRequestId` (FK to TripRequest, optional).
    - Added `driverUserId` and `priceCents` to support TripRequest-based bookings.
- **`TripRequestStatus` enum**:
    - Added `CLOSED` status.
- **`TripRequest` model**:
    - Added `bookings` relation.

#### `src/app/api/offers/[offerId]/accept/route.ts`

- **`POST` handler** (Updated):
    - Wrapped in `prisma.$transaction`.
    - **Logic**:
        1. Verify Offer (`PENDING`) and TripRequest (`ACTIVE`).
        2. Update Offer (`ACCEPTED`).
        3. Create Booking (`CONFIRMED`, linked to TripRequest).
        4. Update TripRequest (`CLOSED`).
        5. Update competing Offers (`CANCELLED`).

#### `src/__tests__/offer-lifecycle.test.ts`

- Updated **Test 5** to verify side effects:
    - Checks `Booking` created with correct driver/price.
    - Checks `TripRequest` status is `CLOSED`.
    - Checks competing offers are `CANCELLED`.
- Updated **Test 7** to verify double-booking prevention on fresh requests.
